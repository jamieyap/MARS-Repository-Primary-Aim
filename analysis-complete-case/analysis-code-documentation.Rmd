---
title: "Analysis Code Documentation"
date: '`r format(Sys.Date(), "%B %d, %Y")`'
output: 
  html_document:
    toc: TRUE
    toc_depth: 4
    number_sections: TRUE
---

<style type="text/css">
.main-container {
  max-width: 1800px !important;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r global_options, include=FALSE}
knitr::opts_chunk$set(tidy = TRUE)
knitr::opts_chunk$set(fig.pos = 'H')
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo = TRUE)
options(width = 7000)
```

```{r}
source("paths.R")
library(knitr)
library(tidyverse)
```

# Documentation for analyses involving the comparison of prompt versus no prompt

```{r}
# This is the R package we will use for analyses involving the comparison of prompt versus no prompt
library(MRTAnalysis)
```

## Overview

We provide documentation on the data processing steps we took to utilize code in the `MRTAnalysis` package to data from the MARS MRT. One of the main differences between the structure of the synthetic dataset for binary outcome that comes with the `MRTAnalysis` package is that in the synthetic dataset, the value for the proximal outcome exists regardless of whether an individual was eligible for micro-randomization at a particular decision point, but this is not the case for data from the MARS study. This is because **by design**, EMAs were only administered if micro-randomization occurred and the proximal outcome was assessed in EMAs. In a similar vein, if a time-varying covariate was assessed via EMAs, then the time-varying covariate can only be assessed if micro-randomization occurred.

More specifically, here is an illustrative example of the difference in the data structures. When creating this example, we used the synthetic dataset in the `MRTAnalysis` package (top) and a slightly modified version of the synthetic dataset (bottom).

```{r}
# data_binary is a synthetic dataset that is included in the MRTAnalysis package
# Display the first 10 rows of the synthetic dataset in the MRTAnalysis package
head(data_binary, 10)
```

```{r}
# This modified copy is an illustrative example of the main difference in
# data structure between the synthetic dataset and data from the MARS study
data_binary_modified <- data_binary
data_binary_modified$Y <- if_else(data_binary_modified$avail == 0, NA, data_binary_modified$Y)
data_binary_modified$time_var1 <- if_else(data_binary_modified$avail == 0, NA, data_binary_modified$time_var1)
data_binary_modified$time_var2 <- if_else(data_binary_modified$avail == 0, NA, data_binary_modified$time_var2)
data_binary_modified$A <- if_else(data_binary_modified$avail == 0, NA, data_binary_modified$A)
data_binary_modified$rand_prob <- if_else(data_binary_modified$avail == 0, NA, data_binary_modified$rand_prob)
# Display the first 10 rows of a modified copy of the synthetic dataset
head(data_binary_modified, 10)
```

When an individual was not eligible for micro-randomization at a particular decision point, the `emee` function in `MRTAnalysis` expects the value of other variables included in any of its arguments to have a non-missing value even if the row will not be used to estimate the treatment effect. Therefore, we performed data pre-processing steps described next to enable data from the MARS study to be compatible for use with functions in the `MRTAnalysis` package.

## Data Pre-Processing Steps

```{r}
# This is the data frame that is the output of the very last step of our data pipeline
dat_primary_aim <- readRDS(file = file.path(path_manipulated_data, "dat_primary_aim.rds"))
```

Data pre-processing steps used:

* Before starting, ensure that eligibility for micro-randomization is dummy coded so that 1 denotes eligible for micro-randomization and 0 denotes not eligible for micro-randomization.
* Whenever an individual is not eligible for micro-randomization at a particular decision point, we replace NA values with some numeric value (could be -1, -99, 0, 9, or 100; it does not really matter) for all the variables which were assessed in EMA; we also do this for the treatment indicator and time variables.
* **Applicable only when performing complete case analysis:** since setting eligibility for micro-randomization to 0 is mathematically equivalent to dropping an observation, we set eligibility to zero whenever micro-randomization happened, but primary proximal outcome was not observed. We also do this if our analysis calls for including other variables (e.g., moderators assessed in EMA).

```{r}
# Bare bones example to illustrate data pre-processing steps for complete case analysis

# Note that this code snippet is specific to complete case analysis
# i.e., we would not do this if we were doing multiply imputed analysis
dat_for_analysis <- dat_primary_aim %>% 
  # This line executes the data pre-processing step that applies to 
  # complete case analysis but not multiply imputed analysis
  # In effect, this indicates that we want to excludes rows which have a 
  # micro-randomization but a missing value in the proximal outcome from estimation of treatment effects.
  # If performing a multiply imputed data analysis, there is no need for the next line
  mutate(eligibility = replace(eligibility, (!is.na(coinflip)) & (is.na(Y)), 0)) 

dat_for_analysis <- dat_for_analysis %>% 
  # The `emee` function in `MRTAnalysis` expects the value of other variables 
  # included in any of its arguments to have a non-missing value even if the 
  # row will not be used to estimate the treatment effect
  mutate(Y = replace(Y, eligibility == 0, -1)) %>% 
  mutate(coinflip = replace(coinflip, eligibility == 0, -1)) %>%
  mutate(days_between_v1_and_coinflip_local = replace(days_between_v1_and_coinflip_local, eligibility == 0, -1))

# The variable in the argument 'id' has to be numeric
# mars_id and participant_id both capture each participant's unique ID:
# mars_id is formatted as a string prefixed by "mars_" followed by a number 
# while participant_id is formatted as a numeric value (just the number part
# of mars_id)
fit1 <- emee(
  data = dat_for_analysis,
  id = "participant_id",  
  outcome = "Y",
  treatment = "coinflip",
  rand_prob = 0.5,
  moderator_formula = ~ days_between_v1_and_coinflip_local,  
  control_formula = ~ days_between_v1_and_coinflip_local, 
  availability = "eligibility"
)

summary(fit1, show_control_fit = TRUE)
```

# Documentation for analyses involving the comparison of high effort prompt versus low effort prompt

```{r}
# These are the custom code we will be using for analyses involving the comparison of high effort prompt versus low effort prompt
source(file = file.path("custom-analysis-code-emee-estimator", "emee_categorical_trt_with_Delta.R"))
source(file = file.path("custom-analysis-code-emee-estimator", "helper_functions.R"))
source(file = file.path("custom-analysis-code-emee-estimator", "emee-categorical-verbose-output.R"))
```

## Overview

We provide documentation on the data processing steps we took to utilize the scripts to data from the MARS MRT. These scripts were specifically developed to enable analysis when there are three or more possible treatment options (i.e., treatment is a categorical variable rather than a binary variable).

* `emee_categorical_trt_with_Delta.R`
* `helper_functions.R`
* `emee-categorical-verbose-output.R`

```{r}
dat_primary_aim <- readRDS(file = file.path(path_manipulated_data, "dat_primary_aim.rds")) 
```

```{r}
# Bare bones example to illustrate data pre-processing steps for complete case analysis
dat_for_analysis <- dat_primary_aim %>%
  select(participant_id, decision_point, eligibility, 
         coinflip, is_high_effort, is_low_effort,
         Y, days_between_v1_and_coinflip_local, baseline_tobacco_history)
```

```{r}
# We will set up the dataset so that in analysis, we may have the following comparisons:
#   * high effort versus low effort
#   * none versus low effort
dat_for_analysis <- dat_for_analysis %>%
  mutate(treatment_cate = case_when(
    is_low_effort == 1 ~ 0,  # Important: the value of zero in treatment_cate is used to indicate the reference category to be used
    is_high_effort == 1 ~ 1, # This allows us to make the comparison: high effort prompt versus low effort prompt
    coinflip == 0 ~ 2,       # This allows us to make the comparison: no prompt versus low effort prompt
    .default = NULL)) %>%
  mutate(rand_prob = case_when(
    treatment_cate == 0 ~ 0.25,
    treatment_cate == 1 ~ 0.25,
    treatment_cate == 2 ~ 0.50,
    .default = NULL))

# rand_prob_A0 is the randomization probability corresponding to the reference category (whatever was coded to take on a value of 0 in treatment_cate)
dat_for_analysis[["rand_prob_A0"]] <- dat_for_analysis %>% filter(treatment_cate == 0) %>% .[["rand_prob"]] %>% unique(.)
```

```{r}
# Note that this data preparation step differs from what we would typically do when we used the MRTAnalysis package.
# When we used the MRTAnalysis package, we would not drop rows in which a participant was ineligible for micro-randomization.
# However, when we use the custom data analysis functions called in this document, we actually drop those rows corresponding to blocks in which a participant was ineligible for micro-randomization.
dat_for_analysis_elig <- dat_for_analysis %>% filter(eligibility == 1)
```

```{r}
# The next line says: among rows corresponding to blocks in which a participant 
# was eligible for micro-randomization, drop the row if they had missing data 
# in any of the variables we specified in the data analysis model
dat_for_analysis_elig <- dat_for_analysis_elig %>% filter(!is.na(Y))
```

```{r}
fit1 <- emee_categorical_trt_with_Delta(
  dta = dat_for_analysis_elig,
  id_varname = "participant_id",
  decision_time_varname = "decision_point",
  treatment_varname = "treatment_cate",
  outcome_varname = "Y",
  control_varname = c("days_between_v1_and_coinflip_local"),
  moderator_varname = c("days_between_v1_and_coinflip_local"),
  rand_prob_varname = "rand_prob",
  rand_prob_A0_varname = "rand_prob_A0",
  avail_varname = NULL,
  rand_prob_tilde_varname = NULL,
  # For MRT with constant randomization probability, 
  # simply set rand_prob_tilde to be equal to the actual randomization probabilities
  # Here, what ever you coded as 0, 1, 2 in treatment_cate
  # specify the randomization probabilities in that order
  rand_prob_tilde = c(0.25, 0.25, 0.50),  
  estimator_initial_value = NULL,
  Delta = 1,
  # Number of treatment categories (important: this must exclude the reference category)
  num_trt = 2  
)
```

```{r}
# The output of emee_categorical_trt_with_Delta does not contain 
# confidence intervals or p-values by default; in this code snippet, we
# call the functions convert_to_emee_fit_object and summary to facilitate this calculation
fit1_converted <- convert_to_emee_fit_object(fit1, dat_for_analysis, "participant_id")
fit1_results <- summary(fit1_converted, show_control_fit = TRUE)
fit1_causal <- fit1_results$causal_excursion_effect
fit1_control <- fit1_results$control_variables
```

```{r}
dat_causal <- data.frame(coefficient = c("beta0", "beta1", "beta2", "beta3"),
                          estimate = round(fit1_causal[,"Estimate"], 3),
                          LCL95 = round(fit1_causal[,"95% LCL"], 3),
                          UCL95 = round(fit1_causal[,"95% UCL"], 3),
                          SE = round(fit1_causal[,"StdErr"], 3),
                          HotellingT = round(fit1_causal[,"t_value"], 3),
                          p = round(fit1_causal[,"p-value"], 3))
```

```{r}
orig_row_names <- row.names(dat_causal)
new_row_names <- orig_row_names
new_row_names <- replace(new_row_names, orig_row_names == "1", "High Effort Prompt (versus Low Effort)")
new_row_names <- replace(new_row_names, orig_row_names == "2", "High Effort Prompt (versus Low Effort) x Day in Study")
new_row_names <- replace(new_row_names, orig_row_names == "3", "No Prompt (versus Low Effort)")
new_row_names <- replace(new_row_names, orig_row_names == "4", "No Prompt (versus Low Effort) x Day in Study")
row.names(dat_causal) <- new_row_names
```

```{r}
knitr::kable(dat_causal)
```

```{r}
dat_control <- data.frame(coefficient = paste("alpha", 0:(length(fit1_control[,"Estimate"])-1), sep=""),
                          estimate = round(fit1_control[,"Estimate"], 3),
                          LCL95 = round(fit1_control[,"95% LCL"], 3),
                          UCL95 = round(fit1_control[,"95% UCL"], 3),
                          SE = round(fit1_control[,"StdErr"], 3),
                          HotellingT = round(fit1_control[,"t_value"], 3),
                          p = round(fit1_control[,"p-value"], 3))
```

```{r}
knitr::kable(dat_control)
```

